【链表】

链表是由许多相同数据类型的数据项，按特定顺序排列而成的线性表。
但链表的特性是其各个数据项在计算机内存中的位置是不连续且随机存放的。
优点是数据的插入或删除都相当方便，有新数据加入就向系统申请一块内存空间，而数据被删除后，
就可以把空间还给系统，加入和删除都不需要移动大量的数据。
其缺点是设计数据结构时较为麻烦，另外在查找数据时，也无法像静态数据（如数组）那样可随机读取数据，
必须按序查找到该数据为止。

日常生活中有许多链表的抽象应用，例如可以把“单向链表”想象成火车，有多少人就接多少节的车厢，当
假日人多时，需要较多车厢时就可多接些车厢，人少时就把车厢数量减少，十分具有弹性。
像游乐场中的摩天轮就是一种“环形链表”的应用，可以根据需要增加车厢的数量。

【动态分配内存】

如果变量或对象在使用动态方式分配内存后，事后必须进行释放的操作，否则这些动态分配的内存会一直存在，
因而造成“内存漏失”(memory leak)的现象。

【C++的动态分配变量】

在C++中，如果要动态分配内存则必须使用new关键词来获取内存地址。如果是单一变量，声明方式如下所示：

     数据类型* 指针名称 = new 数据类型;
或 

     数据类型* 指针名称 = new 数据类型(初值);//指定初始值的声明方式

也可以分为两段式声明：
     
     数据类型* 指针名称 = 0;
     指针名称 = new 数据类型;
或

     数据类型* 指针名称 = 0;
     指针名称 = new 数据类型(初始值);

例如：
    
    int* n = new int;

上列声明中，new关键词的功能是动态地分配一块可以存放int类型数据的内存空间，如果分配操作成功，就会返回
这块内存空间的起始地址，这时指针n就会指向这块内存的起始地址；如果分配操作失败，就会返回NULL（也即是0）,
指针n的内容就是NULL。
在C++中，如果使用动态分配内存方式，用完之后，最好使用delete关键词来释放这些已分配的内存空间，方式如下所示：
    
     delete 指针名称;

【动态分配数组】

当数据声明为数组时，在编译阶段即确定了数组的长度，但是这样很容易造成内存的浪费或无法满足程序所需的问题。
以上问题可以通过动态分配数组的方式来轻松解决。
也就是说，利用动态分配数组，就可以在程序执行时，再临时决定数组的大小。动态分配数组方式与动态分配变量十分类似，
声明后会在内存中自动寻找适合的连续存储空间，其长度必须和指定数据类型再乘以数组长度的乘积相符。
分配完成后，再将该内存区段的起始地址，返回给等号左边所声明的指针变量。

下面就是动态分配一维数组的方式，语法如下：

      数据类型 *指针数组变量 = new 数据类型[元素个数];
   
分配动态数组时，须在中括号内指定预分配数组的元素个数。当分配成功时，系统会返回该数组的起始地址，否则返回NULL值。
当分配的动态数组在程序中已不再使用时，也必须使用delete运算符来释放该动态数组。

delete 运算符释放动态数组的使用格式如下所示：

     delete [] 指针数组变量;

【单向链表】

在动态分配内存空间时，最常使用的就是“单向链表”(single linked list)。
一个单向链表节点基本上由两个元素，即数据字段和指针组成，而指针将会指向下一个元素的内存所在的位置。
在“单向链表”中第一个节点是“链表头指针”，指向最后一个节点的指针设为NULL，表示它是“链表尾”，不指向任何地方。
由于单向链表中所有节点都知道节点本身的下一个节点在哪里，但是对于前一个节点却没有办法知道所以在单向链表的各种操作中，
"链表头指针"就显得相当重要，只要存在链表头指针，就可以遍历整个链表，进行加入和删除节点等操作。注意，除非必要，否则不可移动链表头指针。

【单向链表的创建与遍历】

在C++中，若以动态分配产生链表节点的方式，可以先行定义一个类数据类型，接着在类中定义一个指针变量，其数据类型与此类相同，
作用是指向下一个链表节点，另外类中至少要有一个数据字段。
例如，声明一个学生成绩链表节点的结构，并且包含下面两个数据字段：姓名（name），成绩(score),与一个指针(next)。
接着就可以动态创建链表中的每个节点。

假设现在要新增一个节点至链表的末尾，且ptr指向链表的第一个节点，在程序上必须设计以下4个步骤。

     Step1:动态分配内存空间给新节点使用。
     Step2:将原链表尾部的指针(next)指向新元素所在的内存位置（即内存地址）。
     Step3:将ptr指针指向新节点的内存位置，表示这是新的链表尾部。
     Step4:由于新节点当前为链表的最后一个元素，所以将它的指针(next)指向NULL。

例如要将s1的next变量指向s2的内存地址，而s2的next变量指向NULL。

      s1.next = &s2;
      s2.next = NULL;

由于链表的基本特性就是next变量将会指向下一个节点的内存地址，这时s1节点与s2节点间的关系就是单向链节点建立连接的情况。
遍历(traverse)单向链表中的过程，就是使用指针运算来访问链表中的每个节点。
如果要遍历已建立了3个节点的单向链表，可使用结构指针ptr来作为链表的读取游标，一开始是指向链表的头。
每次读取链表的一个节点，就将ptr往下一个节点移动(即指向下一个节点)，直到ptr指向NULL为止。

有的时候，链表中的节点不只记录单个数值，例如每一个节点除了有指向下一个节点的指针变量外，还包括了记录一位学生的姓名(name),座位(no),
成绩(score)。因此，首先必须声明节点的数据类型，让每一个节点包含一个指针变量，以指向下一个节点，使所有数据能被链接在一起形成一个链表结构。
节点数据类型的声明如下：

    class list   //链表结构的声明
    {            //类内容以(...);包起来
     public:
     int num;//座号
     char name[10];//姓名
     int score;//成绩
     class list *next;//指针变量，指向下一个节点
    };

【单向链表插入新节点】

在单向链表中插入新节点，如同一列火车中加入新的车厢，有3种情况：

     1)加到第1个节点之前
     2)加到最后一个节点之后
     3)加到链表中间任一位置

针对第1种情况，新节点插入第一个节点之前，即成为此链表的首节点:只需把新节点的指针指向
链表原来的第一个节点，再把链表头指针指向新节点即可。

    newnnode->next = first;
    first = newnode;

针对第2种情况，新节点插入最后一个节点之后，只需把链表的最后一个节点的指针指向新节点，
新节点的指针再指向NULL即可。

     ptr->next = newnode;
     newnode->next = NULL;

 针对第3种情况，将新节点插入链表中间的位置:例如插入的节点是在X与Y之间，只要将X节点的指针指向
 新节点，新节点的指针指向Y节点即可。

     newnode->next = x->next;//x的下一个节点成为新节点的下一个节点
     x->next = newnode;//新节点称为x的下一个节点

【单向链表删除节点】

在单向链表类型的数据结构中，若要在链表中删除一个节点，如同一列火车中拿掉原有的车厢，根据所删除节点的位置
会有3种不同的情况。

1)删除链表的第一个节点:只要把链表头指针指向第二个节点即可。

     top=head;
     head=head->next;//将原来第一个节点的下一个节点成为新的第一个节点
     free(top);//销毁头指针

2)删除链表的最后一个节点:只要指向最后一个节点的指针，直接指向NULL即可。

     ptr->next = tail;//ptr暂时拉过来当中间人，将尾指针成为ptr的下一个节点
     ptr->next = NULL;//将ptr的下一个节点置为NULL
     free(tail);//销毁尾指针

3)删除链表内的中间节点：只要将删除节点的前一个节点的指针，指向将要被删除节点的下一个节点即可。

     Y = ptr->next;//Y是ptr的下一个节点的指针，也即ptr是Y的前一个节点的指针
     ptr->next = Y->next;//ptr的下一个节点指向Y的下一个节点；直接跳过Y
     free(Y);//销毁Y

【单向链表的反转】
  
 了解了单向链表节点的删除和插入之后，大家可以发现在这种具有方向性的链表结构中增删节点是相当容易的一件事。
 而从头到尾输出整个单向链表也不难，但是如果要反转过来输出单向链表就需要某些技巧了。
 在单向链表中的节点特性是知道下一个节点的位置，可是却无从得知它的上一个节点的位置。
 如果要将单向链表反转，则必须使用3个指针变量。

    struct list //链表结构的声明
    {
         int num;//学生号码
         int score;//学生分数
         char name[10];//学生姓名
         struct list *next;//指向下一个节点
    };
    typedef struct list node;//定义node新的数据类型
    typedef node *link;//定义link新的数据类型指针
    link invert(link x) //x为链表的开始指针
    {
         link p,q,r;
         p=x;//将p指向链表的开头，p排第1位
         q=NULL;//q是p的前一个节点，q排第0位，且是NULL指针
         while(p!=NULL)
         {
              r=q;//将r接到q之后，r排第0位
              q=p;//将q接到p之后，q排第1位
              p=p->next;//p移到下一个节点，p排第2位
              q->next=r;//q接到之前的节点，q的下一个节点排第0位
         }
         return q;
    }

【环形链表】

  环形链表(circular linked list)的特点是在链表中的任何一个节点，都可以达到此链表内的其他各个节点，建立的过程与单向链表相似，
  唯一的不同点是必须要将最后一个节点指向第一个节点。
  事实上，环形链表的优点是可以从任何一个节点开始遍历所有节点，而且回收整个链表所需的时间是固定的，与长度无关，缺点是需要多一个链接空间，
  而且插入一个节点需要改变两个链接。环形链表的遍历与单向链表十分相似，不过检查环形链表结束的条件是
  
       ptr->next != head
  
  1.环形链表中插入新节点
  对于环形链表的节点插入，与单向链表的插入方式有点不同，由于每一个节点的指针都是指向下一个节点，所以没有所谓从链表尾部插入的问题。
  通常会出现以下两种情况：

  1).将新节点插在第一个节点前成为链表头部：首先将新节点X的指针指向原链表头节点，并遍历整个链表找到链表末尾，将它的指针指向新增节点，
  最后将链表头指针指向新节点。

     x->next = head;//新节点x的下一个节点指向原链表头节点
     CurNode = head;//把头节点视作当前节点的起点

     //环形链表中，需要使用循环遍历整个链表找到链表末尾，条件是当前节点的下一个节点的指针是否指向头节点，是的话，那就说明当前节点的下一个节点指向头指针
     While (CurNode->next != head)  
          CurNode = CurNode->next;//未找到链尾之前，当前节点一直往右移
     //已经不满足while循环的条件退出循环了，那就说明CurNode->next = head;已知当前节点的下一个节点指向头指针，现在指向新节点x
     CurNode->next = x;

     head = x; //新增节点x成为头指针

  2).将新节点X插在链表中任意节点I之后：首先将新节点X的指针指向I节点的下一个节点，并将I节点的指针指向X节点。

     X->next = I->next;
     I->next = X;

  2. 环形链表节点的删除
  环形链表节点的删除与插入方法类似，也分为两种情况:

  1).删除环形链表的第一个节点：首先将链表头指针移到下一个节点，将最后一个节点的指针指向新的链表头部，
   新的链表头部是原链表的第二个节点。

     CurNode = head;

     //环形链表中，需要使用循环遍历整个链表找到链表末尾，条件是当前节点的下一个节点的指针是否指向头节点，是的话，那就说明当前节点的下一个节点指向头指针
     While (CurNode->next != head) 
          CurNode = CurNode->next;//未找到链尾之前，当前节点一直往右移
     //已经不满足while循环的条件退出循环了，那就说明CurNode->next = head;既然如此，当前节点CurNode就是尾指针TailNode
     TailNode = CurNode;

     head = head->next;//将头指针指向的下一个节点赋给新的头节点
     TailNode->next = head;//再次刷新，将尾指针的下一个节点指向新的头节点
 
  2).删除环形链表的中间节点。首先找到节点Y的前一个节点previous,将previous节点的指针指向节点Y的下一个节点。

     CurNode = head;//当前节点从头节点开始

     //环形链表中，删除中间节点del，那就开始循环遍历吧！设置条件：当前节点的下一个节点指向要删除的节点del
     while (CurNode->next != del)  
          CurNode = CurNode->next;//未找到中间节点del之前，当前节点一直往右移
     //找到要删除节点的前一个节点并记录下来
     PreNode = CurNode;//由于CurNode是要删除节点的前一个节点，将它赋给PreNode

     //刷新当前节点，将要删除的节点CurNode->next赋给CurNode;新的CurNode就代表要删除的节点
     CurNode = CurNode->next;
     //将要删除节点CurNode的前一个指针PreNode指向要删除节点CurNode的下一个节点
     PreNode->next = CurNode->next;

  3. 环形链表的连接功能
   单向链表的连接只要改变一个指针就可以了。
   如果是两个环形链表要连接在一起该怎么做呢？因为环形链表没有头尾之分，所以无法直接把环形链表1的尾部指向环形链表2的头部。
   就因为不分头尾，所以不需要遍历链表去寻找链表尾部，直接改变两个指针就可以把两个环形链表连接在一起了。

 【双向链表】

  将两个方向不同的链表结合起来，除了存放数据的字段外，它有两个指针变量，其中一个指针指向后面的节点，另一个则指向前面的节点，
  这样的链表被称为双向链表（double linked list）。
  由于每个节点都有两个指针，可以双向通行，因此能够轻松地找到前后节点，同时从链表中任意的节点也可以找到其他节点，而不需经过
  反转或对比节点等处理，执行速度较快。另外，如果任一节点的链接断裂，可经由反方向链表进行遍历，从而快速重建完整的链表。

  双向链表的最大优点是有两个指针分别指向节点前后两个节点，所以能够轻松地找到前后节点，同时从双向链表中任一节点也可以找到其他节点，而不需经过反转或对比节点等处理，执行速度较快。
  缺点是由于双向链表有两个链接，所以在加入或删除节点时都得花更多时间来调整指针，另外因为每个节点含有两个指针变量，所以比较浪费时间。

  1.双向链表的建立与遍历
     
  1)每个节点具有3个字段，中间为数据字段。左右各有一个指针变量，分别为LLINK和RLINK。其中RLINK指向下一个节点，LLINK指向上一个节点。

  2)通常加上一个链表头指针，此头指针不存储任何数据，其左边指针指向双向链表的最后一个节点，而右边指针则指向双向链表的第一个节点。
    
  3)假设ptr为一指向此双向链表中任一节点的指针，则有：

      Ptr = RLINK(LLINK(ptr)) = LLINK(RLINK(ptr));

  4)建立双向链表的方法，首先就是声明每个节点有3个字段，其声明的数据结构如下所示。

          class _NODE
          {
               public:
                    int DATA;
                    class _NODE* LLINK;
                    class _NODE* RLINK;
          };
          typedef struct_NODE node;
          typedef node* link;
          typedef node* _HEAD;
          typedef node* _INSERTAFTER;
          typedef node* _DELETE;
     
  事实上，双向链表可以是环形，也可以不是环形，如果最后一个节点的右指针指向首节点(即头部节点)，而首节点的左指针指向
  尾节点，这样的链表就称为环形双向链表。另外，为了使用方便，通常加上一个链表头指针，它的数据字段不存放任何数据，其左指针指向链表的最后一个节点，而右指针指向第一个节点(即首节点或头部节点)。
  建立双向链表，其实主要就是多了一个指针。

   双向链表的遍历，可以有往右或往左两方向来进行的两种方式，如果是向右遍历，则和单向链表的遍历相似。
     C++的遍历节点算法如下所示：

          ptr = head->rlink;//设置存取指针从链表头指针的右指针所指的节点开始
          while (ptr !=NULL)
          {
               cout <<"姓名: " << ptr->name <<"\t 学号： "<<ptr->no << "\t 数学成绩: " << ptr->Math << "\t 英文成绩: " << ptr->Eng<< endl;
               ptr = ptr->rlink;//将ptr移往右边下一元素
          }

  2.双向链表中加入新节点

  1)将新节点加入到双向链表的第一个节点之前：将新节点的右指针(RLINK)指向原链表的第一个节点，接着再将原链表第一个节点的左指针(LLINK)指向新节点，将原链表的链表头指针指向新节点。
     C++的算法如下:

          X->rlink = head;//X的右指针指向头节点
          head->llink = X;//头节点的左指针指向X
          head = X;//完成双向指向后，X再成为新的头节点

   2)将新节点X加入双向链表的末尾:将原链表的最后一个节点的右指针指向新节点，将新节点的左指针指向原链表的最后一个节点，并将新节点的右指针指向NULL。
     C++的算法如下所示:

          ptr->rlink = X;//ptr的右指针指向X
          X->rlink = NULL;//X的右指针指向NULL
          X->llink = ptr;//X的左指针指向ptr;完成双向指向

   3)将新节点X加入到链表中的ptr节点之后:首先将ptr节点的右指针指向新节点，再将新节点的左指针指向ptr节点，接着又将
     ptr节点的下一个节点的左指针指向新节点，最后将新节点的右指针指向ptr的下一个节点。
     C++的算法如下所示:

          ptr->rlink->llink = X;//ptr的下一个节点的左指针指向X
          X->rlink = ptr->rlink;//X的右指针等同ptr的右指针
          X->llink = ptr;//X的左指针指向ptr
          ptr->rlink = X;//ptr的右指针指向X  


  3.双向链表节点的删除
     
   双向链表节点的删除和单向链表相似,可分为3种情况：
  1)删除双向链表的第一个节点:将链表头指针head指向原链表的第二个节点，再将新链表头的左指针指向NULL。
   C++的算法如下:

          head = head->rlink;//将头节点移到头节点的下一个节点
          head->llink = NULL;//新的头节点的左指针指向NULL

  2)删除双向链表的最后一个节点X：将原链表最后一个节点之前的一个节点的右指针指向NULL即可。
   C++的算法如下：

          X->llink->rlink = NULL;//将X的上一个节点的右指针指向NULL，直接跳过X

  3)删除双向链表的中间节点X：将X节点的前一个节点的右指针指向X节点的下一个节点，再将ptr节点的下一个节点的左指针指向ptr节点的上一个节点。
   C++的算法如下所示：

          X->llink->rlink = X->rlink;//将X的上一个节点的右指针指向X的下一个节点
          X->rlink->llink = X->llink;//将X的下一个节点的左指针指向X的上一个节点；完成双向指向

  【链表相关应用简介】
  
   1)多项式表示法
    
   使用单向链表来表示多项式，多项式的链表表示法主要是存储非零项，且均采用COEF EXP LINK 3个字段的数据结构，其中COEF 表示非零系数，exp 表示指数的幂次(或指数)，
   而link 是指到下一个节点的指针。多项式的链表表示法存储了非零项。

    步骤一:

         Exp(p) = Exp(q)
     
    步骤二:
          
          Exp(p) > Exp(q)

     步骤三:
          
          Exp(p) = Exp(q)

     
  2）稀疏矩阵表示法
   
  使用3-tuple <row,col,value>的数组结构来表示稀疏矩阵(Sparse matrix)，虽然优点为节省时间，但是当非零项要增删时，会造成数组内大量数据的移动而且程序代码的编写不容易。
  用链表法的最大优点就是:在变更矩阵内的数据时，不需大量移动数据。
  要技巧是用节点来表示非零项，由于矩阵是二维的，因此每个节点除了必须有3个数据字段:row(行)，col(列)和value(值或数据)外，还必须有两个指针变量:right,dowm,其中right指针可用来链接同一行的节点，而down指针则用来链接同一列的节点。

      Value:表示此非零项的值
      Row: 以i表示非零项元素所在行数
      Col: 以j表示非零项元素所在列数
      Down: 为指向同一列中下一个非零项元素的指针
      Right: 为指向同一行中下一个非零项元素的指针

  在稀疏矩阵的数据结构中，每一行与每一列必须用一个环形链表附加一个链表头指针A来表示，
  这个链表的第一个节点内是存放此稀疏矩阵的行与列。上方H1，H2，H3为列首节点，最左方
  H1,H2,H3为行首节点，其他的两个节点分别对应到数组中的非零项。
  而为了模拟二维的稀疏矩阵，所以每一个非零节点会指回行或列的首节点形成环形链表。

